public abstract interface annotation class sk/ainet/context/ContextDsl : java/lang/annotation/Annotation {
}

public abstract interface class sk/ainet/context/ContextDslItem {
}

public final class sk/ainet/context/ContextDslKt {
	public static final fun createDataMap (Lsk/ainet/context/ExecutionContext;Lkotlin/jvm/functions/Function2;)Ljava/util/Map;
	public static synthetic fun createDataMap$default (Lsk/ainet/context/ExecutionContext;Lkotlin/jvm/functions/Function2;ILjava/lang/Object;)Ljava/util/Map;
	public static final fun data (Lsk/ainet/context/ExecutionContext;Lkotlin/jvm/functions/Function2;)V
	public static synthetic fun data$default (Lsk/ainet/context/ExecutionContext;Lkotlin/jvm/functions/Function2;ILjava/lang/Object;)V
}

public final class sk/ainet/context/DefaultDataExecutionContext : sk/ainet/context/ExecutionContext {
	public fun <init> ()V
	public fun <init> (Lsk/ainet/lang/tensor/data/TensorDataFactory;Lsk/ainet/context/Phase;Lsk/ainet/lang/nn/hooks/ForwardHooks;)V
	public synthetic fun <init> (Lsk/ainet/lang/tensor/data/TensorDataFactory;Lsk/ainet/context/Phase;Lsk/ainet/lang/nn/hooks/ForwardHooks;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun fromByteArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/Tensor;
	public fun fromData (Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun getExecutionStats ()Lsk/ainet/context/ExecutionStats;
	public fun getHooks ()Lsk/ainet/lang/nn/hooks/ForwardHooks;
	public fun getInTraining ()Z
	public fun getMemoryInfo ()Lsk/ainet/context/MemoryInfo;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getPhase ()Lsk/ainet/context/Phase;
	public fun getTensorDataFactory ()Lsk/ainet/lang/tensor/data/TensorDataFactory;
	public fun ones (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/context/ExecutionContext {
	public fun fromByteArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/Tensor;
	public fun fromData (Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun getExecutionStats ()Lsk/ainet/context/ExecutionStats;
	public fun getHooks ()Lsk/ainet/lang/nn/hooks/ForwardHooks;
	public fun getInTraining ()Z
	public abstract fun getMemoryInfo ()Lsk/ainet/context/MemoryInfo;
	public abstract fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public abstract fun getPhase ()Lsk/ainet/context/Phase;
	public abstract fun getTensorDataFactory ()Lsk/ainet/lang/tensor/data/TensorDataFactory;
	public fun ones (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/context/ExecutionContext$DefaultImpls {
	public static fun fromByteArray (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromData (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromFloatArray (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromIntArray (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun full (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static fun getHooks (Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/nn/hooks/ForwardHooks;
	public static fun getInTraining (Lsk/ainet/context/ExecutionContext;)Z
	public static fun ones (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public static fun zeros (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/context/ExecutionStats {
	public fun <init> ()V
	public fun <init> (JJDJJ)V
	public synthetic fun <init> (JJDJJILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()J
	public final fun component2 ()J
	public final fun component3 ()D
	public final fun component4 ()J
	public final fun component5 ()J
	public final fun copy (JJDJJ)Lsk/ainet/context/ExecutionStats;
	public static synthetic fun copy$default (Lsk/ainet/context/ExecutionStats;JJDJJILjava/lang/Object;)Lsk/ainet/context/ExecutionStats;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getAverageExecutionTime ()D
	public final fun getOperationsExecuted ()J
	public final fun getPeakMemoryUsage ()J
	public final fun getTensorsCreated ()J
	public final fun getTotalExecutionTime ()J
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/context/MemoryInfo {
	public static final field Companion Lsk/ainet/context/MemoryInfo$Companion;
	public fun <init> (JJJD)V
	public synthetic fun <init> (JJJDILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()J
	public final fun component2 ()J
	public final fun component3 ()J
	public final fun component4 ()D
	public final fun copy (JJJD)Lsk/ainet/context/MemoryInfo;
	public static synthetic fun copy$default (Lsk/ainet/context/MemoryInfo;JJJDILjava/lang/Object;)Lsk/ainet/context/MemoryInfo;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getFreeMemory ()J
	public final fun getTotalMemory ()J
	public final fun getUsagePercentage ()D
	public final fun getUsedMemory ()J
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/context/MemoryInfo$Companion {
	public final fun getEmptyInfo ()Lsk/ainet/context/MemoryInfo;
}

public final class sk/ainet/context/Phase : java/lang/Enum {
	public static final field EVAL Lsk/ainet/context/Phase;
	public static final field TRAIN Lsk/ainet/context/Phase;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lsk/ainet/context/Phase;
	public static fun values ()[Lsk/ainet/context/Phase;
}

public final class sk/ainet/context/PhaseOverridingExecutionContext : sk/ainet/context/ExecutionContext {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lsk/ainet/context/Phase;)V
	public fun fromByteArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/Tensor;
	public fun fromData (Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun getExecutionStats ()Lsk/ainet/context/ExecutionStats;
	public fun getHooks ()Lsk/ainet/lang/nn/hooks/ForwardHooks;
	public fun getInTraining ()Z
	public fun getMemoryInfo ()Lsk/ainet/context/MemoryInfo;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getPhase ()Lsk/ainet/context/Phase;
	public fun getTensorDataFactory ()Lsk/ainet/lang/tensor/data/TensorDataFactory;
	public fun ones (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/context/PhaseScopesKt {
	public static final fun eval (Lsk/ainet/context/ExecutionContext;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
	public static final fun train (Lsk/ainet/context/ExecutionContext;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
}

public final class sk/ainet/lang/nn/Conv2d : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getBias ()Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getGroups ()I
	public final fun getInChannels ()I
	public final fun getKernelSize ()Lkotlin/Pair;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getOutChannels ()I
	public final fun getPadding ()Lkotlin/Pair;
	public fun getParams ()Ljava/util/List;
	public final fun getStride ()Lkotlin/Pair;
	public final fun outputSize (Lkotlin/Pair;)Lkotlin/Pair;
}

public final class sk/ainet/lang/nn/ConversionStats {
	public fun <init> ()V
	public fun <init> (JJJJJJ)V
	public synthetic fun <init> (JJJJJJILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()J
	public final fun component2 ()J
	public final fun component3 ()J
	public final fun component4 ()J
	public final fun component5 ()J
	public final fun component6 ()J
	public final fun copy (JJJJJJ)Lsk/ainet/lang/nn/ConversionStats;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/ConversionStats;JJJJJJILjava/lang/Object;)Lsk/ainet/lang/nn/ConversionStats;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getCacheClears ()J
	public final fun getCacheHitRatio ()D
	public final fun getCacheHits ()J
	public final fun getConversionErrors ()J
	public final fun getConversionRatio ()D
	public final fun getInputConversions ()J
	public final fun getOutputConversions ()J
	public final fun getTotalForwardCalls ()J
	public fun hashCode ()I
	public final fun reset ()V
	public final fun setCacheClears (J)V
	public final fun setCacheHits (J)V
	public final fun setConversionErrors (J)V
	public final fun setInputConversions (J)V
	public final fun setOutputConversions (J)V
	public final fun setTotalForwardCalls (J)V
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/DefaultNeuralNetworkExecutionContext : sk/ainet/lang/nn/NeuralNetworkExecutionContext {
	public fun <init> ()V
	public fun <init> (Lsk/ainet/context/Phase;)V
	public synthetic fun <init> (Lsk/ainet/context/Phase;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun fromByteArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/Tensor;
	public fun fromData (Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun getExecutionStats ()Lsk/ainet/context/ExecutionStats;
	public fun getHooks ()Lsk/ainet/lang/nn/hooks/ForwardHooks;
	public fun getInTraining ()Z
	public fun getMemoryInfo ()Lsk/ainet/context/MemoryInfo;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getPhase ()Lsk/ainet/context/Phase;
	public fun getTensorDataFactory ()Lsk/ainet/lang/tensor/data/TensorDataFactory;
	public fun ones (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/nn/DepthwiseSeparableConv2d : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getBias ()Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getInChannels ()I
	public final fun getKernelSize ()Lkotlin/Pair;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getOutChannels ()I
	public final fun getPadding ()Lkotlin/Pair;
	public fun getParams ()Ljava/util/List;
	public final fun getStride ()Lkotlin/Pair;
	public final fun outputSize (Lkotlin/Pair;)Lkotlin/Pair;
	public final fun parameterCount ()J
	public final fun parameterReduction ()D
}

public final class sk/ainet/lang/nn/DilatedConv2d : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public static final field Companion Lsk/ainet/lang/nn/DilatedConv2d$Companion;
	public fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun dilationInfo ()Lsk/ainet/lang/nn/DilatedConvInfo;
	public final fun effectiveKernelSize ()Lkotlin/Pair;
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getBias ()Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getGroups ()I
	public final fun getInChannels ()I
	public final fun getKernelSize ()Lkotlin/Pair;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getOutChannels ()I
	public final fun getPadding ()Lkotlin/Pair;
	public fun getParams ()Ljava/util/List;
	public final fun getStride ()Lkotlin/Pair;
	public final fun isStandard ()Z
	public final fun outputSize (Lkotlin/Pair;)Lkotlin/Pair;
	public final fun parameterCount ()J
	public final fun receptiveFieldExpansion ()D
	public final fun receptiveFieldSize ()Lkotlin/Pair;
}

public final class sk/ainet/lang/nn/DilatedConv2d$Companion {
	public final fun createMultiScale (IILkotlin/Pair;Ljava/util/List;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
	public static synthetic fun createMultiScale$default (Lsk/ainet/lang/nn/DilatedConv2d$Companion;IILkotlin/Pair;Ljava/util/List;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Ljava/util/List;
}

public final class sk/ainet/lang/nn/DilatedConvInfo {
	public fun <init> (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;DJZ)V
	public final fun component1 ()Lkotlin/Pair;
	public final fun component2 ()Lkotlin/Pair;
	public final fun component3 ()Lkotlin/Pair;
	public final fun component4 ()Lkotlin/Pair;
	public final fun component5 ()D
	public final fun component6 ()J
	public final fun component7 ()Z
	public final fun copy (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;DJZ)Lsk/ainet/lang/nn/DilatedConvInfo;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/DilatedConvInfo;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;DJZILjava/lang/Object;)Lsk/ainet/lang/nn/DilatedConvInfo;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getEffectiveKernelSize ()Lkotlin/Pair;
	public final fun getKernelSize ()Lkotlin/Pair;
	public final fun getParameterCount ()J
	public final fun getReceptiveFieldExpansion ()D
	public final fun getReceptiveFieldSize ()Lkotlin/Pair;
	public fun hashCode ()I
	public final fun isStandard ()Z
	public fun toString ()Ljava/lang/String;
}

public abstract class sk/ainet/lang/nn/DualModule : sk/ainet/lang/nn/topology/ModuleNode {
	public fun <init> ()V
	public abstract fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getChildren ()Ljava/util/List;
	public fun getId ()Ljava/lang/String;
	public abstract fun getModules ()Ljava/util/List;
	public abstract fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
	public fun getPath ()Ljava/lang/String;
	public fun setPath (Ljava/lang/String;)V
}

public final class sk/ainet/lang/nn/DualModuleKt {
	public static final fun compose (Lsk/ainet/lang/nn/DualModule;Lsk/ainet/lang/nn/Module;)Lsk/ainet/lang/nn/DualModule;
	public static final fun compose (Lsk/ainet/lang/nn/Module;Lsk/ainet/lang/nn/DualModule;)Lsk/ainet/lang/nn/DualModule;
}

public final class sk/ainet/lang/nn/Flatten : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (IILjava/lang/String;)V
	public synthetic fun <init> (IILjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/FuncInput {
	public fun <init> (Ljava/lang/String;[I)V
	public synthetic fun <init> (Ljava/lang/String;[IILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()[I
	public final fun copy (Ljava/lang/String;[I)Lsk/ainet/lang/nn/FuncInput;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/FuncInput;Ljava/lang/String;[IILjava/lang/Object;)Lsk/ainet/lang/nn/FuncInput;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDimensions ()[I
	public final fun getName ()Ljava/lang/String;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/Functional {
	public static final field Companion Lsk/ainet/lang/nn/Functional$Companion;
	public synthetic fun <init> (Ljava/util/List;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun forward (Ljava/util/Map;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getInputs ()Ljava/util/List;
}

public final class sk/ainet/lang/nn/Functional$Args {
	public fun <init> (Ljava/util/Map;)V
	public final fun get (Ljava/lang/String;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/nn/Functional$Companion {
	public final fun of (Ljava/util/List;Lkotlin/jvm/functions/Function2;)Lsk/ainet/lang/nn/Functional;
}

public final class sk/ainet/lang/nn/GroupedConv2d : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> (IILkotlin/Pair;ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IILkotlin/Pair;ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun computationalReduction ()D
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getBias ()Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getGroups ()I
	public final fun getInChannels ()I
	public final fun getKernelSize ()Lkotlin/Pair;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getOutChannels ()I
	public final fun getPadding ()Lkotlin/Pair;
	public fun getParams ()Ljava/util/List;
	public final fun getStride ()Lkotlin/Pair;
	public final fun groupInfo ()Lsk/ainet/lang/nn/GroupedConvInfo;
	public final fun inputChannelsPerGroup ()I
	public final fun isDepthwise ()Z
	public final fun isStandard ()Z
	public final fun outputChannelsPerGroup ()I
	public final fun outputSize (Lkotlin/Pair;)Lkotlin/Pair;
	public final fun parameterCount ()J
	public final fun parameterReduction ()D
}

public final class sk/ainet/lang/nn/GroupedConvInfo {
	public fun <init> (IIIJDZZ)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun component3 ()I
	public final fun component4 ()J
	public final fun component5 ()D
	public final fun component6 ()Z
	public final fun component7 ()Z
	public final fun copy (IIIJDZZ)Lsk/ainet/lang/nn/GroupedConvInfo;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/GroupedConvInfo;IIIJDZZILjava/lang/Object;)Lsk/ainet/lang/nn/GroupedConvInfo;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getGroups ()I
	public final fun getInputChannelsPerGroup ()I
	public final fun getOutputChannelsPerGroup ()I
	public final fun getParameterCount ()J
	public final fun getParameterReduction ()D
	public fun hashCode ()I
	public final fun isDepthwise ()Z
	public final fun isStandard ()Z
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/Input : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (Ljava/lang/String;)V
	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public abstract class sk/ainet/lang/nn/InternalMixedPrecisionModule : sk/ainet/lang/nn/Module {
	public fun <init> (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;Lsk/ainet/lang/tensor/ops/MixedPrecisionTensorOps;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	protected abstract fun forwardImpl (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/nn/Linear : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> (IILjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IILjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
}

public final class sk/ainet/lang/nn/MaxPool2d : sk/ainet/lang/nn/Module {
	public fun <init> (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;)V
	public synthetic fun <init> (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getKernelSize ()Lkotlin/Pair;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getPadding ()Lkotlin/Pair;
	public final fun getStride ()Lkotlin/Pair;
	public final fun outputSize (Lkotlin/Pair;)Lkotlin/Pair;
}

public final class sk/ainet/lang/nn/MixedPrecisionException : java/lang/RuntimeException {
	public fun <init> (Ljava/lang/String;Ljava/lang/Throwable;)V
	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/Throwable;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
}

public abstract class sk/ainet/lang/nn/MixedPrecisionModule : sk/ainet/lang/nn/Module {
	public fun <init> (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;Lsk/ainet/lang/tensor/ops/MixedPrecisionTensorOps;)V
	public final fun clearConversionCache ()V
	protected fun convertInput (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	protected fun convertOutput (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public final fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	protected abstract fun forwardImpl (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getAutoConvertInput ()Z
	public final fun getAutoConvertOutput ()Z
	public final fun getCacheSize ()I
	protected final fun getConversionOps ()Lsk/ainet/lang/tensor/ops/MixedPrecisionTensorOps;
	public final fun getConversionStats ()Lsk/ainet/lang/nn/ConversionStats;
	protected final fun getInputType ()Lsk/ainet/lang/types/DType;
	protected final fun getOutputType ()Lsk/ainet/lang/types/DType;
	public final fun setAutoConvertInput (Z)V
	public final fun setAutoConvertOutput (Z)V
	public final fun validatePrecisionConfig ()V
}

public abstract class sk/ainet/lang/nn/Module : sk/ainet/lang/nn/topology/ModuleNode {
	public fun <init> ()V
	public abstract fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getChildren ()Ljava/util/List;
	public fun getId ()Ljava/lang/String;
	public abstract fun getModules ()Ljava/util/List;
	public abstract fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
	public fun getPath ()Ljava/lang/String;
	public fun setPath (Ljava/lang/String;)V
}

public final class sk/ainet/lang/nn/ModuleExtensionsKt {
	public static final fun invoke (Lsk/ainet/lang/nn/Module;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/nn/NeuralNetworkExecutionContext : sk/ainet/context/ExecutionContext {
}

public final class sk/ainet/lang/nn/NeuralNetworkExecutionContext$DefaultImpls {
	public static fun fromByteArray (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromData (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromFloatArray (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromIntArray (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun full (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static fun getHooks (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;)Lsk/ainet/lang/nn/hooks/ForwardHooks;
	public static fun getInTraining (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;)Z
	public static fun ones (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public static fun zeros (Lsk/ainet/lang/nn/NeuralNetworkExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/nn/NeuralNetworkExecutionContextKt {
	public static final fun definition (Lkotlin/jvm/functions/Function2;)Lsk/ainet/lang/nn/Module;
}

public final class sk/ainet/lang/nn/TransposedConv2d : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public static final field Companion Lsk/ainet/lang/nn/TransposedConv2d$Companion;
	public fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getBias ()Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getGroups ()I
	public final fun getInChannels ()I
	public final fun getKernelSize ()Lkotlin/Pair;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getOutChannels ()I
	public final fun getOutputPadding ()Lkotlin/Pair;
	public final fun getPadding ()Lkotlin/Pair;
	public fun getParams ()Ljava/util/List;
	public final fun getStride ()Lkotlin/Pair;
	public final fun is2xUpsampling ()Z
	public final fun isStandard ()Z
	public final fun outputSize (Lkotlin/Pair;)Lkotlin/Pair;
	public final fun parameterCount ()J
	public final fun transposedConvInfo ()Lsk/ainet/lang/nn/TransposedConvInfo;
	public final fun upsamplingFactor ()Lkotlin/Pair;
}

public final class sk/ainet/lang/nn/TransposedConv2d$Companion {
	public final fun customUpsampling (IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/nn/TransposedConv2d;
	public static synthetic fun customUpsampling$default (Lsk/ainet/lang/nn/TransposedConv2d$Companion;IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILjava/lang/Object;)Lsk/ainet/lang/nn/TransposedConv2d;
	public final fun upsampling2x (IILkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/nn/TransposedConv2d;
	public static synthetic fun upsampling2x$default (Lsk/ainet/lang/nn/TransposedConv2d$Companion;IILkotlin/Pair;Lkotlin/Pair;ZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILjava/lang/Object;)Lsk/ainet/lang/nn/TransposedConv2d;
}

public final class sk/ainet/lang/nn/TransposedConvInfo {
	public fun <init> (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ILkotlin/Pair;JZZ)V
	public final fun component1 ()Lkotlin/Pair;
	public final fun component10 ()Z
	public final fun component2 ()Lkotlin/Pair;
	public final fun component3 ()Lkotlin/Pair;
	public final fun component4 ()Lkotlin/Pair;
	public final fun component5 ()Lkotlin/Pair;
	public final fun component6 ()I
	public final fun component7 ()Lkotlin/Pair;
	public final fun component8 ()J
	public final fun component9 ()Z
	public final fun copy (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ILkotlin/Pair;JZZ)Lsk/ainet/lang/nn/TransposedConvInfo;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/TransposedConvInfo;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ILkotlin/Pair;JZZILjava/lang/Object;)Lsk/ainet/lang/nn/TransposedConvInfo;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDilation ()Lkotlin/Pair;
	public final fun getGroups ()I
	public final fun getKernelSize ()Lkotlin/Pair;
	public final fun getOutputPadding ()Lkotlin/Pair;
	public final fun getPadding ()Lkotlin/Pair;
	public final fun getParameterCount ()J
	public final fun getStride ()Lkotlin/Pair;
	public final fun getUpsamplingFactor ()Lkotlin/Pair;
	public fun hashCode ()I
	public final fun is2xUpsampling ()Z
	public final fun isStandard ()Z
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/Upsample2d : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;)V
	public synthetic fun <init> (Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getAlignCorners ()Z
	public final fun getMode ()Lsk/ainet/lang/tensor/ops/UpsampleMode;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getScale ()Lkotlin/Pair;
}

public final class sk/ainet/lang/nn/activations/ActivationsWrapperModule : sk/ainet/lang/nn/Module {
	public fun <init> (Lkotlin/jvm/functions/Function1;Ljava/lang/String;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/activations/GELU : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (Ljava/lang/String;)V
	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/activations/ReLU : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (Ljava/lang/String;)V
	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/activations/SiLU : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (Ljava/lang/String;)V
	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/activations/Sigmoid : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (Ljava/lang/String;)V
	public synthetic fun <init> (Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/activations/Softmax : sk/ainet/lang/nn/Module {
	public fun <init> (ILjava/lang/String;)V
	public synthetic fun <init> (ILjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
}

public abstract interface class sk/ainet/lang/nn/dsl/BiasScope : sk/ainet/lang/tensor/dsl/TensorCreationScope {
}

public final class sk/ainet/lang/nn/dsl/BiasScope$DefaultImpls {
	public static fun from (Lsk/ainet/lang/nn/dsl/BiasScope;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun from (Lsk/ainet/lang/nn/dsl/BiasScope;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromArray (Lsk/ainet/lang/nn/dsl/BiasScope;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromArray (Lsk/ainet/lang/nn/dsl/BiasScope;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromIntList (Lsk/ainet/lang/nn/dsl/BiasScope;Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromList (Lsk/ainet/lang/nn/dsl/BiasScope;Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public static fun full (Lsk/ainet/lang/nn/dsl/BiasScope;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static fun init (Lsk/ainet/lang/nn/dsl/BiasScope;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static fun ones (Lsk/ainet/lang/nn/dsl/BiasScope;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randN (Lsk/ainet/lang/nn/dsl/BiasScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randn (Lsk/ainet/lang/nn/dsl/BiasScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun random (Lsk/ainet/lang/nn/dsl/BiasScope;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randomInit (Lsk/ainet/lang/nn/dsl/BiasScope;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun uniform (Lsk/ainet/lang/nn/dsl/BiasScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun zeros (Lsk/ainet/lang/nn/dsl/BiasScope;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/nn/dsl/BiasScopeImpl : sk/ainet/lang/nn/dsl/BiasScope {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)V
	public fun from ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun from ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun getDtype ()Lkotlin/reflect/KClass;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun init (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun ones ()Lsk/ainet/lang/tensor/Tensor;
	public fun randN (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun randn (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun random (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun randomInit (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun uniform (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros ()Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/nn/dsl/CONV2D : sk/ainet/lang/nn/dsl/NetworkDslItem, sk/ainet/lang/nn/dsl/WandBTensorValueContext {
	public abstract fun getBias ()Z
	public abstract fun getDilation ()Lkotlin/Pair;
	public abstract fun getGroups ()I
	public abstract fun getInChannels ()I
	public abstract fun getKernelSize ()Lkotlin/Pair;
	public abstract fun getOutChannels ()I
	public abstract fun getPadding ()Lkotlin/Pair;
	public abstract fun getStride ()Lkotlin/Pair;
	public abstract fun kernelSize (I)V
	public abstract fun padding (I)V
	public abstract fun setBias (Z)V
	public abstract fun setDilation (Lkotlin/Pair;)V
	public abstract fun setGroups (I)V
	public abstract fun setInChannels (I)V
	public abstract fun setKernelSize (Lkotlin/Pair;)V
	public abstract fun setOutChannels (I)V
	public abstract fun setPadding (Lkotlin/Pair;)V
	public abstract fun setStride (Lkotlin/Pair;)V
	public abstract fun stride (I)V
}

public final class sk/ainet/lang/nn/dsl/Conv2dImpl : sk/ainet/lang/nn/dsl/CONV2D {
	public fun <init> (Lsk/ainet/context/ExecutionContext;IILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/reflect/KClass;)V
	public fun bias (Lkotlin/jvm/functions/Function2;)V
	public final fun create ()Lsk/ainet/lang/nn/Conv2d;
	public fun getBias ()Z
	public fun getBiasShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getDilation ()Lkotlin/Pair;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getGroups ()I
	public fun getInChannels ()I
	public fun getKernelSize ()Lkotlin/Pair;
	public fun getOutChannels ()I
	public fun getPadding ()Lkotlin/Pair;
	public fun getStride ()Lkotlin/Pair;
	public fun getWeightsShape ()Lsk/ainet/lang/tensor/Shape;
	public fun kernelSize (I)V
	public fun padding (I)V
	public fun setBias (Z)V
	public fun setDilation (Lkotlin/Pair;)V
	public fun setGroups (I)V
	public fun setInChannels (I)V
	public fun setKernelSize (Lkotlin/Pair;)V
	public fun setOutChannels (I)V
	public fun setPadding (Lkotlin/Pair;)V
	public fun setStride (Lkotlin/Pair;)V
	public fun stride (I)V
	public fun weights (Lkotlin/jvm/functions/Function2;)V
}

public abstract interface class sk/ainet/lang/nn/dsl/DENSE : sk/ainet/lang/nn/dsl/NetworkDslItem, sk/ainet/lang/nn/dsl/WandBTensorValueContext {
	public abstract fun getActivation ()Lkotlin/jvm/functions/Function1;
	public abstract fun getUnits ()I
	public abstract fun setActivation (Lkotlin/jvm/functions/Function1;)V
	public abstract fun setUnits (I)V
}

public final class sk/ainet/lang/nn/dsl/DenseImpl : sk/ainet/lang/nn/dsl/DENSE {
	public fun <init> (Lsk/ainet/context/ExecutionContext;IILjava/lang/String;Lkotlin/reflect/KClass;)V
	public fun bias (Lkotlin/jvm/functions/Function2;)V
	public final fun create ()Ljava/util/List;
	public fun getActivation ()Lkotlin/jvm/functions/Function1;
	public fun getBiasShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public final fun getOutputDimension ()I
	public fun getUnits ()I
	public fun getWeightsShape ()Lsk/ainet/lang/tensor/Shape;
	public fun setActivation (Lkotlin/jvm/functions/Function1;)V
	public fun setUnits (I)V
	public fun weights (Lkotlin/jvm/functions/Function2;)V
}

public abstract interface class sk/ainet/lang/nn/dsl/FLATTEN : sk/ainet/lang/nn/dsl/NetworkDslItem {
	public abstract fun getEndDim ()I
	public abstract fun getStartDim ()I
	public abstract fun setEndDim (I)V
	public abstract fun setStartDim (I)V
}

public final class sk/ainet/lang/nn/dsl/FlattenImpl : sk/ainet/lang/nn/dsl/FLATTEN {
	public fun <init> (Lsk/ainet/context/ExecutionContext;IILjava/lang/String;)V
	public synthetic fun <init> (Lsk/ainet/context/ExecutionContext;IILjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun create ()Lsk/ainet/lang/nn/Module;
	public fun getEndDim ()I
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getStartDim ()I
	public fun setEndDim (I)V
	public fun setStartDim (I)V
}

public abstract interface class sk/ainet/lang/nn/dsl/MAXPOOL2D : sk/ainet/lang/nn/dsl/NetworkDslItem {
	public abstract fun getKernelSize ()Lkotlin/Pair;
	public abstract fun getPadding ()Lkotlin/Pair;
	public abstract fun getStride ()Lkotlin/Pair;
	public abstract fun kernelSize (I)V
	public abstract fun padding (I)V
	public abstract fun setKernelSize (Lkotlin/Pair;)V
	public abstract fun setPadding (Lkotlin/Pair;)V
	public abstract fun setStride (Lkotlin/Pair;)V
	public abstract fun stride (I)V
}

public final class sk/ainet/lang/nn/dsl/MaxPool2dImpl : sk/ainet/lang/nn/dsl/MAXPOOL2D {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;)V
	public final fun create ()Lsk/ainet/lang/nn/MaxPool2d;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getKernelSize ()Lkotlin/Pair;
	public fun getPadding ()Lkotlin/Pair;
	public fun getStride ()Lkotlin/Pair;
	public fun kernelSize (I)V
	public fun padding (I)V
	public fun setKernelSize (Lkotlin/Pair;)V
	public fun setPadding (Lkotlin/Pair;)V
	public fun setStride (Lkotlin/Pair;)V
	public fun stride (I)V
}

public final class sk/ainet/lang/nn/dsl/NetworkBuilder {
	public fun <init> ()V
	public final fun add ([Lsk/ainet/lang/nn/Module;)Lsk/ainet/lang/nn/dsl/NetworkBuilder;
	public final fun build ()Lsk/ainet/lang/nn/Module;
}

public abstract interface annotation class sk/ainet/lang/nn/dsl/NetworkDsl : java/lang/annotation/Annotation {
}

public abstract interface class sk/ainet/lang/nn/dsl/NetworkDslItem {
	public abstract fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
}

public abstract interface class sk/ainet/lang/nn/dsl/NeuralNetworkDsl : sk/ainet/lang/nn/dsl/NetworkDslItem {
	public abstract fun activation (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public static synthetic fun activation$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public abstract fun batchNorm (IDDZLjava/lang/String;)V
	public static synthetic fun batchNorm$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;IDDZLjava/lang/String;ILjava/lang/Object;)V
	public abstract fun conv2d (ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public abstract fun conv2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public static synthetic fun conv2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun conv2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public abstract fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public abstract fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public abstract fun dense (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public abstract fun dense (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lsk/ainet/lang/nn/Module;
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lsk/ainet/lang/nn/Module;
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public abstract fun flatten (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public static synthetic fun flatten$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public abstract fun groupNorm (IIDZLjava/lang/String;)V
	public static synthetic fun groupNorm$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;IIDZLjava/lang/String;ILjava/lang/Object;)V
	public abstract fun input (ILjava/lang/String;)V
	public static synthetic fun input$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;ILjava/lang/Object;)V
	public abstract fun layerNorm ([IDZLjava/lang/String;)V
	public static synthetic fun layerNorm$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;[IDZLjava/lang/String;ILjava/lang/Object;)V
	public abstract fun maxPool2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public abstract fun maxPool2d (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;)V
	public static synthetic fun maxPool2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun maxPool2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;ILjava/lang/Object;)V
	public abstract fun sequential (Lkotlin/jvm/functions/Function1;)V
	public abstract fun softmax (ILjava/lang/String;)V
	public static synthetic fun softmax$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;ILjava/lang/Object;)V
	public abstract fun stage (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public abstract fun stage (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public abstract fun upsample2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public abstract fun upsample2d (Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;)V
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;ILjava/lang/Object;)V
}

public final class sk/ainet/lang/nn/dsl/NeuralNetworkDsl$DefaultImpls {
	public static synthetic fun activation$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun batchNorm$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;IDDZLjava/lang/String;ILjava/lang/Object;)V
	public static synthetic fun conv2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun conv2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lsk/ainet/lang/nn/Module;
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lsk/ainet/lang/nn/Module;
	public static synthetic fun dense$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun flatten$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun groupNorm$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;IIDZLjava/lang/String;ILjava/lang/Object;)V
	public static synthetic fun input$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;ILjava/lang/Object;)V
	public static synthetic fun layerNorm$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;[IDZLjava/lang/String;ILjava/lang/Object;)V
	public static synthetic fun maxPool2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun maxPool2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;ILjava/lang/Object;)V
	public static synthetic fun softmax$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;ILjava/lang/String;ILjava/lang/Object;)V
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/nn/dsl/NeuralNetworkDsl;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;ILjava/lang/Object;)V
}

public final class sk/ainet/lang/nn/dsl/NeuralNetworkDslImpl : sk/ainet/lang/nn/dsl/NeuralNetworkDsl {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;)V
	public fun activation (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun batchNorm (IDDZLjava/lang/String;)V
	public fun conv2d (ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun conv2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public final fun create ()Lsk/ainet/lang/nn/Module;
	public fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun dense (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public fun dense (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun flatten (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public final fun getLastDimension ()I
	public final fun getModules ()Ljava/util/List;
	public fun groupNorm (IIDZLjava/lang/String;)V
	public fun input (ILjava/lang/String;)V
	public fun layerNorm ([IDZLjava/lang/String;)V
	public fun maxPool2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun maxPool2d (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;)V
	public fun sequential (Lkotlin/jvm/functions/Function1;)V
	public final fun setLastDimension (I)V
	public fun softmax (ILjava/lang/String;)V
	public fun stage (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public fun stage (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun upsample2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun upsample2d (Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;)V
}

public abstract interface class sk/ainet/lang/nn/dsl/PrecisionResolver {
	public abstract fun resolvePrecision (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/nn/dsl/StageImpl : sk/ainet/lang/nn/dsl/NeuralNetworkDsl {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Ljava/lang/String;Lkotlin/reflect/KClass;)V
	public fun activation (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun batchNorm (IDDZLjava/lang/String;)V
	public fun conv2d (ILkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IZLjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun conv2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public final fun create ()Lsk/ainet/lang/nn/Module;
	public fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public fun dense (ILjava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun dense (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public fun dense (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun flatten (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public final fun getInputDimension ()I
	public final fun getLastDimension ()I
	public final fun getModules ()Ljava/util/List;
	public fun groupNorm (IIDZLjava/lang/String;)V
	public fun input (ILjava/lang/String;)V
	public fun layerNorm ([IDZLjava/lang/String;)V
	public fun maxPool2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun maxPool2d (Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;Ljava/lang/String;)V
	public fun sequential (Lkotlin/jvm/functions/Function1;)V
	public final fun setInputDimension (I)V
	public final fun setLastDimension (I)V
	public fun softmax (ILjava/lang/String;)V
	public fun stage (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/nn/Module;
	public fun stage (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun upsample2d (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
	public fun upsample2d (Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;)V
}

public abstract interface class sk/ainet/lang/nn/dsl/UPSAMPLE2D : sk/ainet/lang/nn/dsl/NetworkDslItem {
	public abstract fun getAlignCorners ()Z
	public abstract fun getMode ()Lsk/ainet/lang/tensor/ops/UpsampleMode;
	public abstract fun getScale ()Lkotlin/Pair;
	public abstract fun scale (I)V
	public abstract fun setAlignCorners (Z)V
	public abstract fun setMode (Lsk/ainet/lang/tensor/ops/UpsampleMode;)V
	public abstract fun setScale (Lkotlin/Pair;)V
}

public final class sk/ainet/lang/nn/dsl/Upsample2dImpl : sk/ainet/lang/nn/dsl/UPSAMPLE2D {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZLjava/lang/String;)V
	public final fun create ()Lsk/ainet/lang/nn/Upsample2d;
	public fun getAlignCorners ()Z
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getMode ()Lsk/ainet/lang/tensor/ops/UpsampleMode;
	public fun getScale ()Lkotlin/Pair;
	public fun scale (I)V
	public fun setAlignCorners (Z)V
	public fun setMode (Lsk/ainet/lang/tensor/ops/UpsampleMode;)V
	public fun setScale (Lkotlin/Pair;)V
}

public abstract interface class sk/ainet/lang/nn/dsl/WandBTensorValueContext {
	public abstract fun bias (Lkotlin/jvm/functions/Function2;)V
	public abstract fun getBiasShape ()Lsk/ainet/lang/tensor/Shape;
	public abstract fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public abstract fun getWeightsShape ()Lsk/ainet/lang/tensor/Shape;
	public abstract fun weights (Lkotlin/jvm/functions/Function2;)V
}

public abstract interface class sk/ainet/lang/nn/dsl/WeightsScope : sk/ainet/lang/tensor/dsl/TensorCreationScope {
}

public final class sk/ainet/lang/nn/dsl/WeightsScope$DefaultImpls {
	public static fun from (Lsk/ainet/lang/nn/dsl/WeightsScope;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun from (Lsk/ainet/lang/nn/dsl/WeightsScope;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromArray (Lsk/ainet/lang/nn/dsl/WeightsScope;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromArray (Lsk/ainet/lang/nn/dsl/WeightsScope;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromIntList (Lsk/ainet/lang/nn/dsl/WeightsScope;Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromList (Lsk/ainet/lang/nn/dsl/WeightsScope;Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public static fun full (Lsk/ainet/lang/nn/dsl/WeightsScope;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static fun init (Lsk/ainet/lang/nn/dsl/WeightsScope;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static fun ones (Lsk/ainet/lang/nn/dsl/WeightsScope;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randN (Lsk/ainet/lang/nn/dsl/WeightsScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randn (Lsk/ainet/lang/nn/dsl/WeightsScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun random (Lsk/ainet/lang/nn/dsl/WeightsScope;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randomInit (Lsk/ainet/lang/nn/dsl/WeightsScope;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun uniform (Lsk/ainet/lang/nn/dsl/WeightsScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static fun zeros (Lsk/ainet/lang/nn/dsl/WeightsScope;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/nn/dsl/WeightsScopeImpl : sk/ainet/lang/nn/dsl/WeightsScope {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)V
	public fun from ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun from ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun getDtype ()Lkotlin/reflect/KClass;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun init (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun ones ()Lsk/ainet/lang/tensor/Tensor;
	public fun randN (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun randn (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun random (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun randomInit (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun uniform (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros ()Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/nn/hooks/ForwardHooks {
	public abstract fun onForwardBegin (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/Object;)V
	public abstract fun onForwardEnd (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/Object;Ljava/lang/Object;)V
}

public final class sk/ainet/lang/nn/hooks/HooksSupportKt {
	public static final fun withForwardHooks (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
}

public final class sk/ainet/lang/nn/hooks/TapeRecorder : sk/ainet/lang/nn/hooks/ForwardHooks {
	public fun <init> ()V
	public final fun getTape ()Ljava/util/List;
	public fun onForwardBegin (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/Object;)V
	public fun onForwardEnd (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/Object;Ljava/lang/Object;)V
}

public final class sk/ainet/lang/nn/hooks/TapeRecorder$Entry {
	public fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lsk/ainet/lang/tensor/ops/TensorSpec;Lsk/ainet/lang/tensor/ops/TensorSpec;Ljava/util/List;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Ljava/lang/String;
	public final fun component3 ()Ljava/lang/String;
	public final fun component4 ()Lsk/ainet/lang/tensor/ops/TensorSpec;
	public final fun component5 ()Lsk/ainet/lang/tensor/ops/TensorSpec;
	public final fun component6 ()Ljava/util/List;
	public final fun copy (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lsk/ainet/lang/tensor/ops/TensorSpec;Lsk/ainet/lang/tensor/ops/TensorSpec;Ljava/util/List;)Lsk/ainet/lang/nn/hooks/TapeRecorder$Entry;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/hooks/TapeRecorder$Entry;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lsk/ainet/lang/tensor/ops/TensorSpec;Lsk/ainet/lang/tensor/ops/TensorSpec;Ljava/util/List;ILjava/lang/Object;)Lsk/ainet/lang/nn/hooks/TapeRecorder$Entry;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getInputSpec ()Lsk/ainet/lang/tensor/ops/TensorSpec;
	public final fun getModuleId ()Ljava/lang/String;
	public final fun getModuleName ()Ljava/lang/String;
	public final fun getModulePath ()Ljava/lang/String;
	public final fun getOutputSpec ()Lsk/ainet/lang/tensor/ops/TensorSpec;
	public final fun getParamRefs ()Ljava/util/List;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/layers/Dropout : sk/ainet/lang/nn/Module {
	public fun <init> ()V
	public fun <init> (FZLjava/lang/String;)V
	public synthetic fun <init> (FZLjava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getP ()F
	public final fun getTraining ()Z
	public final fun setTraining (Z)V
}

public final class sk/ainet/lang/nn/layers/Embedding : sk/ainet/lang/nn/DualModule, sk/ainet/lang/nn/topology/ModuleParameters {
	public static final field Companion Lsk/ainet/lang/nn/layers/Embedding$Companion;
	public fun <init> (IILsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;Ljava/lang/String;)V
	public synthetic fun <init> (IILsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;Lsk/ainet/lang/nn/layers/EmbeddingParams;Ljava/lang/String;FFLkotlin/random/Random;)V
	public synthetic fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;Lsk/ainet/lang/nn/layers/EmbeddingParams;Ljava/lang/String;FFLkotlin/random/Random;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun forward ([ILsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun forward ([JLsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public final fun forwardAny (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;Z)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun forwardAny$default (Lsk/ainet/lang/nn/layers/Embedding;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public final fun getEmbeddingDim ()I
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public final fun getNumEmbeddings ()I
	public final fun getPaddingIdx ()Ljava/lang/Integer;
	public fun getParams ()Ljava/util/List;
}

public final class sk/ainet/lang/nn/layers/Embedding$Companion {
}

public final class sk/ainet/lang/nn/layers/EmbeddingParams {
	public fun <init> (IILjava/lang/Integer;Ljava/lang/Float;Z)V
	public synthetic fun <init> (IILjava/lang/Integer;Ljava/lang/Float;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun component3 ()Ljava/lang/Integer;
	public final fun component4 ()Ljava/lang/Float;
	public final fun component5 ()Z
	public final fun copy (IILjava/lang/Integer;Ljava/lang/Float;Z)Lsk/ainet/lang/nn/layers/EmbeddingParams;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/layers/EmbeddingParams;IILjava/lang/Integer;Ljava/lang/Float;ZILjava/lang/Object;)Lsk/ainet/lang/nn/layers/EmbeddingParams;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getEmbeddingDim ()I
	public final fun getMaxNorm ()Ljava/lang/Float;
	public final fun getNumEmbeddings ()I
	public final fun getPaddingIdx ()Ljava/lang/Integer;
	public final fun getScaleGradByFreq ()Z
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/normalization/BatchNormalization : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> (IDDZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IDDZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun eval ()V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
	public final fun train ()V
}

public final class sk/ainet/lang/nn/normalization/GroupNormalization : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> (IIDZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> (IIDZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
}

public final class sk/ainet/lang/nn/normalization/LayerNormalization : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> ([IDZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)V
	public synthetic fun <init> ([IDZLjava/lang/String;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
}

public final class sk/ainet/lang/nn/reflection/ModelSummaryKt {
	public static final fun describe (Lsk/ainet/lang/nn/Module;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;I)Ljava/lang/String;
	public static synthetic fun describe$default (Lsk/ainet/lang/nn/Module;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;IILjava/lang/Object;)Ljava/lang/String;
}

public final class sk/ainet/lang/nn/reflection/NodeSummary {
	public fun <init> (Ljava/lang/String;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/tensor/Shape;J)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lsk/ainet/lang/tensor/Shape;
	public final fun component3 ()Lsk/ainet/lang/tensor/Shape;
	public final fun component4 ()J
	public final fun copy (Ljava/lang/String;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/tensor/Shape;J)Lsk/ainet/lang/nn/reflection/NodeSummary;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/reflection/NodeSummary;Ljava/lang/String;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/tensor/Shape;JILjava/lang/Object;)Lsk/ainet/lang/nn/reflection/NodeSummary;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getInput ()Lsk/ainet/lang/tensor/Shape;
	public final fun getName ()Ljava/lang/String;
	public final fun getOutput ()Lsk/ainet/lang/tensor/Shape;
	public final fun getParams ()J
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/reflection/Summary {
	public fun <init> (Lsk/ainet/context/ExecutionContext;)V
	public final fun getNodes ()Ljava/util/List;
	public final fun printSummary (Ljava/util/List;)Ljava/lang/String;
	public final fun summary (Lsk/ainet/lang/nn/Module;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;I)Ljava/util/List;
	public static synthetic fun summary$default (Lsk/ainet/lang/nn/reflection/Summary;Lsk/ainet/lang/nn/Module;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;IILjava/lang/Object;)Ljava/util/List;
}

public final class sk/ainet/lang/nn/topology/MLP : sk/ainet/lang/nn/Module, sk/ainet/lang/nn/topology/ModuleParameters {
	public fun <init> ([Lsk/ainet/lang/nn/Module;Ljava/lang/String;)V
	public synthetic fun <init> ([Lsk/ainet/lang/nn/Module;Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun forward (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
	public fun getModules ()Ljava/util/List;
	public fun getName ()Ljava/lang/String;
	public fun getParams ()Ljava/util/List;
}

public abstract interface class sk/ainet/lang/nn/topology/ModuleNode {
	public abstract fun getChildren ()Ljava/util/List;
	public abstract fun getId ()Ljava/lang/String;
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun getParams ()Ljava/util/List;
	public abstract fun getPath ()Ljava/lang/String;
	public abstract fun setPath (Ljava/lang/String;)V
}

public abstract class sk/ainet/lang/nn/topology/ModuleNodeAdapter : sk/ainet/lang/nn/topology/ModuleNode {
	public fun <init> ()V
	public fun getPath ()Ljava/lang/String;
	public fun setPath (Ljava/lang/String;)V
}

public abstract class sk/ainet/lang/nn/topology/ModuleParameter {
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun getValue ()Lsk/ainet/lang/tensor/Tensor;
	public abstract fun setValue (Lsk/ainet/lang/tensor/Tensor;)V
}

public final class sk/ainet/lang/nn/topology/ModuleParameter$BiasParameter : sk/ainet/lang/nn/topology/ModuleParameter {
	public fun <init> (Ljava/lang/String;Lsk/ainet/lang/tensor/Tensor;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lsk/ainet/lang/tensor/Tensor;
	public final fun copy (Ljava/lang/String;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/nn/topology/ModuleParameter$BiasParameter;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/topology/ModuleParameter$BiasParameter;Ljava/lang/String;Lsk/ainet/lang/tensor/Tensor;ILjava/lang/Object;)Lsk/ainet/lang/nn/topology/ModuleParameter$BiasParameter;
	public fun equals (Ljava/lang/Object;)Z
	public fun getName ()Ljava/lang/String;
	public fun getValue ()Lsk/ainet/lang/tensor/Tensor;
	public fun hashCode ()I
	public fun setValue (Lsk/ainet/lang/tensor/Tensor;)V
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/nn/topology/ModuleParameter$WeightParameter : sk/ainet/lang/nn/topology/ModuleParameter {
	public fun <init> (Ljava/lang/String;Lsk/ainet/lang/tensor/Tensor;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Lsk/ainet/lang/tensor/Tensor;
	public final fun copy (Ljava/lang/String;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/nn/topology/ModuleParameter$WeightParameter;
	public static synthetic fun copy$default (Lsk/ainet/lang/nn/topology/ModuleParameter$WeightParameter;Ljava/lang/String;Lsk/ainet/lang/tensor/Tensor;ILjava/lang/Object;)Lsk/ainet/lang/nn/topology/ModuleParameter$WeightParameter;
	public fun equals (Ljava/lang/Object;)Z
	public fun getName ()Ljava/lang/String;
	public fun getValue ()Lsk/ainet/lang/tensor/Tensor;
	public fun hashCode ()I
	public fun setValue (Lsk/ainet/lang/tensor/Tensor;)V
	public fun toString ()Ljava/lang/String;
}

public abstract interface class sk/ainet/lang/nn/topology/ModuleParameters {
	public abstract fun getParams ()Ljava/util/List;
}

public final class sk/ainet/lang/nn/topology/ModuleParametersKt {
	public static final fun bias (Ljava/util/List;)Lsk/ainet/lang/nn/topology/ModuleParameter$BiasParameter;
	public static final fun by (Ljava/util/List;Ljava/lang/String;)Lsk/ainet/lang/nn/topology/ModuleParameter;
	public static final fun weights (Ljava/util/List;)Lsk/ainet/lang/nn/topology/ModuleParameter$WeightParameter;
}

public final class sk/ainet/lang/nn/topology/TraversalKt {
	public static final fun bindPaths (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/String;Ljava/lang/String;)V
	public static synthetic fun bindPaths$default (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/String;Ljava/lang/String;ILjava/lang/Object;)V
	public static final fun collectParams (Lsk/ainet/lang/nn/topology/ModuleNode;)Ljava/util/List;
	public static final fun findById (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/String;)Lsk/ainet/lang/nn/topology/ModuleNode;
	public static final fun findByPath (Lsk/ainet/lang/nn/topology/ModuleNode;Ljava/lang/String;)Lsk/ainet/lang/nn/topology/ModuleNode;
	public static final fun walkDepthFirst (Lsk/ainet/lang/nn/topology/ModuleNode;Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ainet/lang/tensor/ContiguityAnalysis {
	public fun <init> (ZIIDLjava/util/List;Ljava/lang/String;)V
	public final fun component1 ()Z
	public final fun component2 ()I
	public final fun component3 ()I
	public final fun component4 ()D
	public final fun component5 ()Ljava/util/List;
	public final fun component6 ()Ljava/lang/String;
	public final fun copy (ZIIDLjava/util/List;Ljava/lang/String;)Lsk/ainet/lang/tensor/ContiguityAnalysis;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/ContiguityAnalysis;ZIIDLjava/util/List;Ljava/lang/String;ILjava/lang/Object;)Lsk/ainet/lang/tensor/ContiguityAnalysis;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDimensionMatches ()Ljava/util/List;
	public final fun getParentVolume ()I
	public final fun getReason ()Ljava/lang/String;
	public final fun getViewVolume ()I
	public final fun getVolumeRatio ()D
	public fun hashCode ()I
	public final fun isContiguous ()Z
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/CopyMaterializationStrategy : sk/ainet/lang/tensor/MaterializationStrategy {
	public fun <init> ()V
	public fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public fun estimateMemoryOverhead (Lsk/ainet/lang/tensor/TensorView;)J
	public fun getName ()Ljava/lang/String;
	public fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
}

public class sk/ainet/lang/tensor/DefaultTensorViewStrategy : sk/ainet/lang/tensor/TensorViewStrategy {
	public fun <init> ()V
	public fun getDecisionReason (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Ljava/lang/String;
	public final fun getMaxStrideThreshold ()I
	public final fun getViewSizeThreshold ()D
	public final fun setMaxStrideThreshold (I)V
	public final fun setViewSizeThreshold (D)V
	public fun shouldCreateView (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Z
}

public abstract interface class sk/ainet/lang/tensor/IndexMapper {
	public abstract fun getStride ()[I
	public abstract fun isContiguous ()Z
	public abstract fun mapToParent ([I)[I
}

public final class sk/ainet/lang/tensor/IndexOutOfRangeException : java/lang/IllegalArgumentException {
	public fun <init> (Ljava/lang/String;)V
}

public final class sk/ainet/lang/tensor/IndexTensor {
	public static final synthetic fun box-impl (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/IndexTensor;
	public static fun constructor-impl (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun equals (Ljava/lang/Object;)Z
	public static fun equals-impl (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Object;)Z
	public static final fun equals-impl0 (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Z
	public final fun getT ()Lsk/ainet/lang/tensor/Tensor;
	public fun hashCode ()I
	public static fun hashCode-impl (Lsk/ainet/lang/tensor/Tensor;)I
	public fun toString ()Ljava/lang/String;
	public static fun toString-impl (Lsk/ainet/lang/tensor/Tensor;)Ljava/lang/String;
	public final synthetic fun unbox-impl ()Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/IndexTensorKt {
	public static final fun asIndices (Lsk/ainet/lang/tensor/Tensor;Z)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun asIndices$default (Lsk/ainet/lang/tensor/Tensor;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/LazyMaterializationStrategy : sk/ainet/lang/tensor/MaterializationStrategy {
	public fun <init> ()V
	public fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public fun estimateMemoryOverhead (Lsk/ainet/lang/tensor/TensorView;)J
	public final fun forceMaterialize (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun getName ()Ljava/lang/String;
	public fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/MaterializationExtensionsKt {
	public static final fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public static final fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;Lsk/ainet/lang/tensor/MaterializationStrategy;)Z
	public static final fun estimateMaterializationCost (Lsk/ainet/lang/tensor/TensorView;)J
	public static final fun estimateMaterializationCost (Lsk/ainet/lang/tensor/TensorView;Lsk/ainet/lang/tensor/MaterializationStrategy;)J
	public static final fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun materialize (Lsk/ainet/lang/tensor/TensorView;Lsk/ainet/lang/tensor/MaterializationStrategy;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/tensor/MaterializationStrategy {
	public abstract fun canMaterialize (Lsk/ainet/lang/tensor/TensorView;)Z
	public abstract fun estimateMemoryOverhead (Lsk/ainet/lang/tensor/TensorView;)J
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun materialize (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/MemoryAwareTensorViewStrategy : sk/ainet/lang/tensor/DefaultTensorViewStrategy {
	public fun <init> ()V
	public fun getDecisionReason (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Ljava/lang/String;
	public final fun getMemoryPressureThreshold ()D
	public final fun getPressureViewSizeThreshold ()D
	public final fun setMemoryPressureThreshold (D)V
	public final fun setPressureViewSizeThreshold (D)V
	public fun shouldCreateView (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Z
}

public final class sk/ainet/lang/tensor/NCHWIndexMapper : sk/ainet/lang/tensor/IndexMapper {
	public fun <init> (Lsk/ainet/lang/tensor/Shape;Ljava/util/List;Lsk/ainet/lang/tensor/Shape;)V
	public fun getStride ()[I
	public fun isContiguous ()Z
	public fun mapToParent ([I)[I
}

public final class sk/ainet/lang/tensor/NCHWSlicePattern : java/lang/Enum {
	public static final field BATCH_SLICE Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field CHANNEL_SLICE Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field OTHER Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field SPATIAL_REGION Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final field WIDTH_SLICE Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static fun values ()[Lsk/ainet/lang/tensor/NCHWSlicePattern;
}

public final class sk/ainet/lang/tensor/NonIntegralIndexException : java/lang/IllegalArgumentException {
	public fun <init> (Ljava/lang/String;)V
}

public final class sk/ainet/lang/tensor/PprintKt {
	public static final fun pprint (Lsk/ainet/lang/tensor/Tensor;)Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/SegmentBuilder {
	public fun <init> (I)V
	public final fun all ()Lsk/ainet/lang/tensor/Slice;
	public final fun at (I)Lsk/ainet/lang/tensor/Slice;
	public final fun range (II)Lsk/ainet/lang/tensor/Slice;
	public final fun step (III)Lsk/ainet/lang/tensor/Slice;
	public final fun unaryMinus (Lkotlin/ranges/IntRange;)Lsk/ainet/lang/tensor/Slice;
	public final fun unaryPlus (Lkotlin/ranges/IntRange;)Lsk/ainet/lang/tensor/Slice;
}

public final class sk/ainet/lang/tensor/Shape {
	public static final field Companion Lsk/ainet/lang/tensor/Shape$Companion;
	public fun <init> ([I)V
	public final fun component1 ()[I
	public final fun copy ([I)Lsk/ainet/lang/tensor/Shape;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Shape;[IILjava/lang/Object;)Lsk/ainet/lang/tensor/Shape;
	public fun equals (Ljava/lang/Object;)Z
	public final fun get (I)I
	public final fun getDimensions ()[I
	public final fun getRank ()I
	public final fun getVolume ()I
	public fun hashCode ()I
	public final fun index ([I)I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Shape$Companion {
	public final fun invoke ([I)Lsk/ainet/lang/tensor/Shape;
}

public abstract class sk/ainet/lang/tensor/Slice {
	public final fun getResultSize (I)I
	public final fun hasNonTrivialStride ()Z
	public final fun isContiguous ()Z
	public final fun isEmpty ()Z
	public final fun isValid (I)Z
	public final fun normalize (I)Lsk/ainet/lang/tensor/Slice;
}

public final class sk/ainet/lang/tensor/Slice$All : sk/ainet/lang/tensor/Slice {
	public fun <init> ()V
	public fun equals (Ljava/lang/Object;)Z
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Slice$At : sk/ainet/lang/tensor/Slice {
	public fun <init> (I)V
	public final fun component1 ()I
	public final fun copy (I)Lsk/ainet/lang/tensor/Slice$At;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Slice$At;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Slice$At;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getIndex ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Slice$Range : sk/ainet/lang/tensor/Slice {
	public fun <init> (II)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun copy (II)Lsk/ainet/lang/tensor/Slice$Range;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Slice$Range;IIILjava/lang/Object;)Lsk/ainet/lang/tensor/Slice$Range;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getEnd ()I
	public final fun getStart ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/Slice$Step : sk/ainet/lang/tensor/Slice {
	public fun <init> (III)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun component3 ()I
	public final fun copy (III)Lsk/ainet/lang/tensor/Slice$Step;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/Slice$Step;IIIILjava/lang/Object;)Lsk/ainet/lang/tensor/Slice$Step;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getEnd ()I
	public final fun getStart ()I
	public final fun getStep ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/SliceIndexMapper : sk/ainet/lang/tensor/IndexMapper {
	public fun <init> (Lsk/ainet/lang/tensor/Shape;Ljava/util/List;Lsk/ainet/lang/tensor/Shape;)V
	public final fun canVectorize ()Z
	public final fun getAccessPattern ()Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public fun getStride ()[I
	public fun isContiguous ()Z
	public fun mapToParent ([I)[I
}

public final class sk/ainet/lang/tensor/SliceIndexMapper$AccessPattern : java/lang/Enum {
	public static final field CONTIGUOUS_COMPLEX Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static final field CONTIGUOUS_SIMPLE Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static final field NON_CONTIGUOUS Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
	public static fun values ()[Lsk/ainet/lang/tensor/SliceIndexMapper$AccessPattern;
}

public final class sk/ainet/lang/tensor/SlicedTensorView : sk/ainet/lang/tensor/TensorView {
	public fun <init> (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)V
	public fun getData ()Lsk/ainet/lang/tensor/data/TensorData;
	public fun getDtype ()Lkotlin/reflect/KClass;
	public fun getIndexMapping ()Lsk/ainet/lang/tensor/IndexMapper;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getParentTensor ()Lsk/ainet/lang/tensor/Tensor;
	public fun getRank ()I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public final fun getSliceOperations ()Ljava/util/List;
	public fun getViewShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getVolume ()I
}

public abstract interface class sk/ainet/lang/tensor/Tensor {
	public abstract fun getData ()Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun getDtype ()Lkotlin/reflect/KClass;
	public abstract fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getRank ()I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getVolume ()I
}

public final class sk/ainet/lang/tensor/Tensor$DefaultImpls {
	public static fun getRank (Lsk/ainet/lang/tensor/Tensor;)I
	public static fun getShape (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Shape;
	public static fun getVolume (Lsk/ainet/lang/tensor/Tensor;)I
}

public final class sk/ainet/lang/tensor/TensorExtensionsKt {
	public static final fun div (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun div (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun div (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun flatten (Lsk/ainet/lang/tensor/Tensor;II)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun flatten$default (Lsk/ainet/lang/tensor/Tensor;IIILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun gelu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun matmul (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun mean (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun mean$default (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun minus (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun minus (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun minus (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun plus (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun plus (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun plus (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun relu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun reshape (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun sigmoid (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun silu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun softmax (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun softmax$default (Lsk/ainet/lang/tensor/Tensor;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun sqrt (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun sum (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun sum$default (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun t (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun times (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun times (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun times (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun tril (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun tril$default (Lsk/ainet/lang/tensor/Tensor;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun upsample2d (Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;Z)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun variance (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun variance$default (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/tensor/TensorFactory {
	public abstract fun constructTensor (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun ones (Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun zeros (Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/TensorSliceBuilder {
	public fun <init> ()V
	public final fun segment (Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ainet/lang/tensor/TensorSlicingExtensionsKt {
	public static final fun detectNCHWSlicePattern (Ljava/util/List;)Lsk/ainet/lang/tensor/NCHWSlicePattern;
	public static final fun isContiguousSlice (Ljava/util/List;)Z
	public static final fun slice (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceAt (Lsk/ainet/lang/tensor/Tensor;[I)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceCopy (Lsk/ainet/lang/tensor/Tensor;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static final fun sliceRanges (Lsk/ainet/lang/tensor/Tensor;[Lkotlin/Pair;)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceView (Lsk/ainet/lang/tensor/Tensor;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/TensorView;
	public static final fun sliceView (Lsk/ainet/lang/tensor/TensorView;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/TensorView;
}

public abstract interface class sk/ainet/lang/tensor/TensorView : sk/ainet/lang/tensor/Tensor {
	public abstract fun getIndexMapping ()Lsk/ainet/lang/tensor/IndexMapper;
	public abstract fun getParentTensor ()Lsk/ainet/lang/tensor/Tensor;
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public abstract fun getViewShape ()Lsk/ainet/lang/tensor/Shape;
}

public final class sk/ainet/lang/tensor/TensorView$DefaultImpls {
	public static fun getRank (Lsk/ainet/lang/tensor/TensorView;)I
	public static fun getShape (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/Shape;
	public static fun getVolume (Lsk/ainet/lang/tensor/TensorView;)I
}

public abstract interface class sk/ainet/lang/tensor/TensorViewStrategy {
	public abstract fun getDecisionReason (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Ljava/lang/String;
	public abstract fun shouldCreateView (Lsk/ainet/lang/tensor/Tensor;Ljava/util/List;)Z
}

public final class sk/ainet/lang/tensor/TesnorExtKt {
	public static final fun isMatrix (Lsk/ainet/lang/tensor/Tensor;)Z
	public static final fun isScalar (Lsk/ainet/lang/tensor/Tensor;)Z
	public static final fun isVector (Lsk/ainet/lang/tensor/Tensor;)Z
}

public final class sk/ainet/lang/tensor/ViewManagementExtensionsKt {
	public static final fun analyzeContiguity (Lsk/ainet/lang/tensor/TensorView;)Lsk/ainet/lang/tensor/ContiguityAnalysis;
	public static final fun batchMaterialize (Ljava/util/List;)Ljava/util/List;
	public static final fun batchMaterialize (Ljava/util/List;Lsk/ainet/lang/tensor/MaterializationStrategy;)Ljava/util/List;
	public static final fun estimateBatchMaterializationCost (Ljava/util/List;)J
	public static final fun estimateBatchMaterializationCost (Ljava/util/List;Lsk/ainet/lang/tensor/MaterializationStrategy;)J
	public static final fun isContiguous (Lsk/ainet/lang/tensor/TensorView;)Z
}

public final class sk/ainet/lang/tensor/VoidOpsTensor : sk/ainet/lang/tensor/Tensor {
	public fun <init> (Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;)V
	public fun getData ()Lsk/ainet/lang/tensor/data/TensorData;
	public fun getDtype ()Lkotlin/reflect/KClass;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getRank ()I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getVolume ()I
}

public final class sk/ainet/lang/tensor/benchmark/BenchmarkConfig {
	public fun <init> ()V
	public fun <init> (IILjava/util/List;Z)V
	public synthetic fun <init> (IILjava/util/List;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()I
	public final fun component2 ()I
	public final fun component3 ()Ljava/util/List;
	public final fun component4 ()Z
	public final fun copy (IILjava/util/List;Z)Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;IILjava/util/List;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getIncludeMemoryBenchmarks ()Z
	public final fun getIterations ()I
	public final fun getTensorShapes ()Ljava/util/List;
	public final fun getWarmupIterations ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/benchmark/BenchmarkReporter {
	public fun <init> ()V
	public final fun compareResults (Ljava/util/List;Ljava/util/List;)Ljava/lang/String;
	public final fun generateReport (Ljava/util/List;Ljava/lang/String;)Ljava/lang/String;
	public static synthetic fun generateReport$default (Lsk/ainet/lang/tensor/benchmark/BenchmarkReporter;Ljava/util/List;Ljava/lang/String;ILjava/lang/Object;)Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/benchmark/BenchmarkResult {
	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Ljava/lang/String;
	public final fun component3 ()Ljava/lang/String;
	public final fun component4-UwyO8pc ()J
	public final fun component5 ()Ljava/lang/Long;
	public final fun component6 ()Ljava/lang/Double;
	public final fun copy-gwCluXo (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;)Lsk/ainet/lang/tensor/benchmark/BenchmarkResult;
	public static synthetic fun copy-gwCluXo$default (Lsk/ainet/lang/tensor/benchmark/BenchmarkResult;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JLjava/lang/Long;Ljava/lang/Double;ILjava/lang/Object;)Lsk/ainet/lang/tensor/benchmark/BenchmarkResult;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDuration-UwyO8pc ()J
	public final fun getMemoryUsage ()Ljava/lang/Long;
	public final fun getOperationType ()Ljava/lang/String;
	public final fun getSlicePattern ()Ljava/lang/String;
	public final fun getTensorSize ()Ljava/lang/String;
	public final fun getThroughput ()Ljava/lang/Double;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite {
	public fun <init> ()V
	public final fun benchmarkAccessPatterns (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;)Ljava/util/List;
	public static synthetic fun benchmarkAccessPatterns$default (Lsk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;ILjava/lang/Object;)Ljava/util/List;
	public final fun benchmarkMLScenarios (Lkotlin/jvm/functions/Function1;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;)Ljava/util/List;
	public static synthetic fun benchmarkMLScenarios$default (Lsk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite;Lkotlin/jvm/functions/Function1;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;ILjava/lang/Object;)Ljava/util/List;
	public final fun benchmarkViewVsCopy (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;)Ljava/util/List;
	public static synthetic fun benchmarkViewVsCopy$default (Lsk/ainet/lang/tensor/benchmark/SlicingBenchmarkSuite;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/benchmark/BenchmarkConfig;ILjava/lang/Object;)Ljava/util/List;
}

public final class sk/ainet/lang/tensor/data/DenseFloatArrayTensorData : sk/ainet/lang/tensor/data/FloatArrayTensorData {
	public fun <init> (Lsk/ainet/lang/tensor/Shape;[F)V
	public fun get ([I)Ljava/lang/Float;
	public synthetic fun get ([I)Ljava/lang/Object;
	public fun getBuffer ()[F
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([IF)V
	public synthetic fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/DenseIntArrayTensorData : sk/ainet/lang/tensor/data/IntArrayTensorData {
	public fun <init> (Lsk/ainet/lang/tensor/Shape;[I)V
	public fun get ([I)Ljava/lang/Integer;
	public synthetic fun get ([I)Ljava/lang/Object;
	public fun getBuffer ()[I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([II)V
	public synthetic fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/DenseTensorDataFactory : sk/ainet/lang/tensor/data/TensorDataFactory {
	public fun <init> ()V
	public fun fromByteArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun fromByteArray ([BLsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;[FLsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun fromFloatArray ([FLsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun fromIntArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun fromIntArray ([ILsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun full (Lsk/ainet/lang/tensor/Shape;Ljava/lang/Number;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun full (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun init (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun matrix ([[Ljava/lang/Object;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun ones (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun randn (Lsk/ainet/lang/tensor/Shape;FFLsk/ainet/lang/types/DType;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun randn (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public static synthetic fun randn$default (Lsk/ainet/lang/tensor/data/DenseTensorDataFactory;Lsk/ainet/lang/tensor/Shape;FFLsk/ainet/lang/types/DType;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun randomInit (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun randomInt (Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/types/DType;Lkotlin/random/Random;Lkotlin/jvm/functions/Function2;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun scalar (Ljava/lang/Object;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun uniform (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public final fun vector ([Ljava/lang/Object;)Lsk/ainet/lang/tensor/data/TensorData;
	public fun zeros (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/data/TensorData;
}

public abstract interface class sk/ainet/lang/tensor/data/FloatArrayTensorData : sk/ainet/lang/tensor/data/TensorData {
	public abstract fun getBuffer ()[F
}

public abstract interface class sk/ainet/lang/tensor/data/IntArrayTensorData : sk/ainet/lang/tensor/data/TensorData {
	public abstract fun getBuffer ()[I
}

public abstract interface class sk/ainet/lang/tensor/data/ItemsAccessor {
	public abstract fun get ([I)Ljava/lang/Object;
	public abstract fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/PprintKt {
	public static final fun pprint (Lsk/ainet/lang/tensor/data/TensorData;)Ljava/lang/String;
}

public abstract interface class sk/ainet/lang/tensor/data/TensorData : sk/ainet/lang/tensor/data/ItemsAccessor {
	public abstract fun getShape ()Lsk/ainet/lang/tensor/Shape;
}

public abstract interface class sk/ainet/lang/tensor/data/TensorDataFactory {
	public abstract fun fromByteArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[B)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun fromFloatArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[F)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun fromIntArray (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;[I)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun full (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Ljava/lang/Number;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun init (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun ones (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun randn (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun randomInit (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun uniform (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/data/TensorData;
	public abstract fun zeros (Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/data/TensorData;
}

public final class sk/ainet/lang/tensor/data/TensorFactoryRegistry {
	public static final field INSTANCE Lsk/ainet/lang/tensor/data/TensorFactoryRegistry;
	public final fun getFactory (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/data/TensorDataFactory;
	public final fun hasFactory (Lsk/ainet/lang/types/DType;)Z
	public final fun registerFactory (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/tensor/data/TensorDataFactory;)V
}

public final class sk/ainet/lang/tensor/data/dense/DenseByteTensorArray : sk/ainet/lang/tensor/data/ItemsAccessor {
	public fun <init> (Ljava/util/List;[B)V
	public fun <init> (Lsk/ainet/lang/tensor/Shape;[BI)V
	public synthetic fun <init> (Lsk/ainet/lang/tensor/Shape;[BIILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun get ([I)Ljava/lang/Byte;
	public synthetic fun get ([I)Ljava/lang/Object;
	public final fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([IB)V
	public synthetic fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/dense/DenseFloatTensorArray : sk/ainet/lang/tensor/data/ItemsAccessor {
	public fun <init> (Ljava/util/List;[F)V
	public fun <init> (Lsk/ainet/lang/tensor/Shape;[FI)V
	public synthetic fun <init> (Lsk/ainet/lang/tensor/Shape;[FIILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun get ([I)Ljava/lang/Float;
	public synthetic fun get ([I)Ljava/lang/Object;
	public final fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([IF)V
	public synthetic fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/dense/DenseInt4TensorArray : sk/ainet/lang/tensor/data/ItemsAccessor {
	public fun <init> (Ljava/util/List;[B)V
	public fun <init> (Lsk/ainet/lang/tensor/Shape;[BI)V
	public synthetic fun <init> (Lsk/ainet/lang/tensor/Shape;[BIILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun get ([I)Ljava/lang/Integer;
	public synthetic fun get ([I)Ljava/lang/Object;
	public final fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([II)V
	public synthetic fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/dense/DenseTernaryTensorArray : sk/ainet/lang/tensor/data/ItemsAccessor {
	public static final field Companion Lsk/ainet/lang/tensor/data/dense/DenseTernaryTensorArray$Companion;
	public fun <init> (Ljava/util/List;[B)V
	public fun <init> (Lsk/ainet/lang/tensor/Shape;[BI)V
	public synthetic fun <init> (Lsk/ainet/lang/tensor/Shape;[BIILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun get ([I)Ljava/lang/Byte;
	public synthetic fun get ([I)Ljava/lang/Object;
	public final fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([IB)V
	public synthetic fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/data/dense/DenseTernaryTensorArray$Companion {
	public final fun requiredBytesForElements (I)I
}

public final class sk/ainet/lang/tensor/data/views/UnsqueezedTensorData : sk/ainet/lang/tensor/data/TensorData {
	public fun <init> (Lsk/ainet/lang/tensor/data/TensorData;I)V
	public fun get ([I)Ljava/lang/Object;
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun set ([ILjava/lang/Object;)V
}

public final class sk/ainet/lang/tensor/dsl/ConvKernel {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun conv3x3 (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun conv5x5 (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun oihw (IIII)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun pointwise (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun square (III)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
}

public abstract interface class sk/ainet/lang/tensor/dsl/DataContextDsl : sk/ainet/context/ContextDslItem {
	public abstract fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public abstract fun matrix (JJLkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun scalar (Ljava/lang/Object;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun tensor (Lkotlin/reflect/KClass;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun tensor (Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun vector (JLkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/dsl/ImageExtensionsKt {
	public static final fun image (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/ImageTensor;
	public static final fun imageInit (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;)Lsk/ainet/lang/tensor/dsl/ImageInitializers;
	public static final fun kernel (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/ConvKernel;
}

public final class sk/ainet/lang/tensor/dsl/ImageInitializers {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;)V
	public final fun black ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun imagenetNormalized (Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun imagenetNormalized$default (Lsk/ainet/lang/tensor/dsl/ImageInitializers;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun normalizedPixels (Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun normalizedPixels$default (Lsk/ainet/lang/tensor/dsl/ImageInitializers;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun pixelRange (Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun pixelRange$default (Lsk/ainet/lang/tensor/dsl/ImageInitializers;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun white ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/ImageTensor {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun bchw (IIII)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun chw (III)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun grayscale (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun rgb (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun rgba (II)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
}

public abstract class sk/ainet/lang/tensor/dsl/InitializationType {
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Custom : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (Lkotlin/jvm/functions/Function1;)V
	public final fun component1 ()Lkotlin/jvm/functions/Function1;
	public final fun copy (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/dsl/InitializationType$Custom;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Custom;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Custom;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getGenerator ()Lkotlin/jvm/functions/Function1;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Fill : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (Ljava/lang/Number;)V
	public final fun component1 ()Ljava/lang/Number;
	public final fun copy (Ljava/lang/Number;)Lsk/ainet/lang/tensor/dsl/InitializationType$Fill;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Fill;Ljava/lang/Number;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Fill;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getValue ()Ljava/lang/Number;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Normal : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (FFLkotlin/random/Random;)V
	public final fun component1 ()F
	public final fun component2 ()F
	public final fun component3 ()Lkotlin/random/Random;
	public final fun copy (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/InitializationType$Normal;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Normal;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Normal;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getMean ()F
	public final fun getRandom ()Lkotlin/random/Random;
	public final fun getStd ()F
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Ones : sk/ainet/lang/tensor/dsl/InitializationType {
	public static final field INSTANCE Lsk/ainet/lang/tensor/dsl/InitializationType$Ones;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$RandomCustom : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)V
	public final fun component1 ()Lkotlin/jvm/functions/Function1;
	public final fun component2 ()Lkotlin/random/Random;
	public final fun copy (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/InitializationType$RandomCustom;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$RandomCustom;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$RandomCustom;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getGenerator ()Lkotlin/jvm/functions/Function1;
	public final fun getRandom ()Lkotlin/random/Random;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Uniform : sk/ainet/lang/tensor/dsl/InitializationType {
	public fun <init> (FFLkotlin/random/Random;)V
	public final fun component1 ()F
	public final fun component2 ()F
	public final fun component3 ()Lkotlin/random/Random;
	public final fun copy (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/InitializationType$Uniform;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/dsl/InitializationType$Uniform;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/InitializationType$Uniform;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getMax ()F
	public final fun getMin ()F
	public final fun getRandom ()Lkotlin/random/Random;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/dsl/InitializationType$Zeros : sk/ainet/lang/tensor/dsl/InitializationType {
	public static final field INSTANCE Lsk/ainet/lang/tensor/dsl/InitializationType$Zeros;
}

public final class sk/ainet/lang/tensor/dsl/MLPBias {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun constant (ILjava/lang/Number;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun normal (IFFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun normal$default (Lsk/ainet/lang/tensor/dsl/MLPBias;IFFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun ones (I)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun zeros (I)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/MLPExtensionsKt {
	public static final fun bias (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/MLPBias;
	public static final fun weights (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)Lsk/ainet/lang/tensor/dsl/MLPWeights;
}

public final class sk/ainet/lang/tensor/dsl/MLPWeights {
	public fun <init> (Lsk/ainet/lang/tensor/dsl/TensorBuilder;)V
	public final fun he (IILkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun he$default (Lsk/ainet/lang/tensor/dsl/MLPWeights;IILkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun normal (IIFFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun normal$default (Lsk/ainet/lang/tensor/dsl/MLPWeights;IIFFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun ones (II)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun xavier (IILkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun xavier$default (Lsk/ainet/lang/tensor/dsl/MLPWeights;IILkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun zeros (II)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/ShapeBuilder {
	public fun <init> (Lkotlin/reflect/KClass;Lsk/ainet/lang/tensor/Shape;)V
	public final fun fill (Ljava/lang/Number;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun init (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun ones ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun randn (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun randn$default (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun randomInit (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun randomInit$default (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun uniform (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public static synthetic fun uniform$default (Lsk/ainet/lang/tensor/dsl/ShapeBuilder;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/dsl/TensorInitializer;
	public final fun zeros ()Lsk/ainet/lang/tensor/dsl/TensorInitializer;
}

public final class sk/ainet/lang/tensor/dsl/TensorBuilder {
	public fun <init> (Lkotlin/reflect/KClass;)V
	public final fun shape (Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
	public final fun shape ([I)Lsk/ainet/lang/tensor/dsl/ShapeBuilder;
}

public abstract interface class sk/ainet/lang/tensor/dsl/TensorContextDslItem {
}

public abstract interface class sk/ainet/lang/tensor/dsl/TensorCreationScope {
	public fun from ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun from ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun getDtype ()Lkotlin/reflect/KClass;
	public abstract fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public abstract fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun init (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun ones ()Lsk/ainet/lang/tensor/Tensor;
	public fun randN (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun randN$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public fun randn (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun randn$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public fun random (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun randomInit (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun randomInit$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public fun uniform (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun uniform$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros ()Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/dsl/TensorCreationScope$DefaultImpls {
	public static fun from (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun from (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromArray (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;[F)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromArray (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;[I)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromIntList (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public static fun fromList (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public static fun full (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public static fun init (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static fun ones (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randN (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun randN$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randn (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun randn$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static fun random (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public static fun randomInit (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun randomInit$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static fun uniform (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun uniform$default (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;FFLkotlin/random/Random;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static fun zeros (Lsk/ainet/lang/tensor/dsl/TensorCreationScope;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/dsl/TensorCreationScopeImpl : sk/ainet/lang/tensor/dsl/TensorCreationScope {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lsk/ainet/lang/tensor/Shape;Lkotlin/reflect/KClass;)V
	public fun from ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun from ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([F)Lsk/ainet/lang/tensor/Tensor;
	public fun fromArray ([I)Lsk/ainet/lang/tensor/Tensor;
	public fun fromIntList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun fromList (Ljava/util/List;)Lsk/ainet/lang/tensor/Tensor;
	public fun full (Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun getDtype ()Lkotlin/reflect/KClass;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun init (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun ones ()Lsk/ainet/lang/tensor/Tensor;
	public fun randN (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun randn (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun random (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun randomInit (Lkotlin/jvm/functions/Function1;Lkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun uniform (FFLkotlin/random/Random;)Lsk/ainet/lang/tensor/Tensor;
	public fun zeros ()Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/dsl/TensorDSLKt {
	public static final fun tensor (Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/tensor/dsl/TensorDefineDsl : sk/ainet/lang/tensor/dsl/TensorContextDslItem {
	public abstract fun tensor (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface annotation class sk/ainet/lang/tensor/dsl/TensorDsl : java/lang/annotation/Annotation {
}

public final class sk/ainet/lang/tensor/dsl/TensorFactoryContext {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;)V
	public final fun shape (Lsk/ainet/lang/tensor/Shape;Lkotlin/jvm/functions/Function2;)Lsk/ainet/lang/tensor/Tensor;
	public final fun shape ([ILkotlin/jvm/functions/Function2;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/dsl/TensorInitializer {
	public fun <init> (Lkotlin/reflect/KClass;Lsk/ainet/lang/tensor/Shape;Lsk/ainet/lang/tensor/dsl/InitializationType;)V
	public final fun build (Lsk/ainet/context/ExecutionContext;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/tensor/dsl/TypedDataContextDsl : sk/ainet/lang/tensor/dsl/DataContextDsl {
	public abstract fun getDefaultDType ()Lkotlin/reflect/KClass;
	public abstract fun matrix (JJLkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun scalar (Ljava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun tensor (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun tensor (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun vector (JLkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/dsl/TypedDataContextDslImpl : sk/ainet/lang/tensor/dsl/TypedDataContextDsl {
	public fun <init> (Lsk/ainet/context/ExecutionContext;Lkotlin/reflect/KClass;)V
	public fun getDefaultDType ()Lkotlin/reflect/KClass;
	public fun getExecutionContext ()Lsk/ainet/context/ExecutionContext;
	public fun matrix (JJLkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun matrix (JJLkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun scalar (Ljava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public fun scalar (Ljava/lang/Object;Lkotlin/reflect/KClass;)Lsk/ainet/lang/tensor/Tensor;
	public fun tensor (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun tensor (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun tensor (Lkotlin/reflect/KClass;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun tensor (Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun vector (JLkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
	public fun vector (JLkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/operators/OperatorsKt {
	public static final fun withOps (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/ops/TensorOps;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/operators/OpsBoundTensor : sk/ainet/lang/tensor/Tensor {
	public fun <init> (Lsk/ainet/lang/tensor/data/TensorData;Lkotlin/reflect/KClass;Lsk/ainet/lang/tensor/ops/TensorOps;)V
	public fun getData ()Lsk/ainet/lang/tensor/data/TensorData;
	public fun getDtype ()Lkotlin/reflect/KClass;
	public fun getOps ()Lsk/ainet/lang/tensor/ops/TensorOps;
	public fun getRank ()I
	public fun getShape ()Lsk/ainet/lang/tensor/Shape;
	public fun getVolume ()I
}

public final class sk/ainet/lang/tensor/ops/AddOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public abstract class sk/ainet/lang/tensor/ops/BaseOperation : sk/ainet/lang/tensor/ops/Operation {
	public fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun equals (Ljava/lang/Object;)Z
	public fun getDescription ()Ljava/lang/String;
	public fun getName ()Ljava/lang/String;
	public fun getParameters ()Ljava/util/Map;
	public fun getType ()Ljava/lang/String;
	public fun hashCode ()I
	public fun serialize ()Ljava/util/Map;
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/ops/Conv2dOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/DivideOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/FlattenOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/InputOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/MatmulOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/MaxPool2dOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public abstract interface class sk/ainet/lang/tensor/ops/MixedPrecisionTensorOps : sk/ainet/lang/tensor/ops/TensorOps {
	public abstract fun addMixed (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun convert (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/ops/MultiplyOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public abstract interface class sk/ainet/lang/tensor/ops/Operation {
	public abstract fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public static synthetic fun clone$default (Lsk/ainet/lang/tensor/ops/Operation;Ljava/util/Map;ILjava/lang/Object;)Lsk/ainet/lang/tensor/ops/Operation;
	public abstract fun execute (Ljava/util/List;)Ljava/util/List;
	public fun getDescription ()Ljava/lang/String;
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun getParameters ()Ljava/util/Map;
	public abstract fun getType ()Ljava/lang/String;
	public abstract fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public abstract fun serialize ()Ljava/util/Map;
	public abstract fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/Operation$DefaultImpls {
	public static synthetic fun clone$default (Lsk/ainet/lang/tensor/ops/Operation;Ljava/util/Map;ILjava/lang/Object;)Lsk/ainet/lang/tensor/ops/Operation;
	public static fun getDescription (Lsk/ainet/lang/tensor/ops/Operation;)Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/ops/ReluOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/ReshapeOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/SigmoidOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/SoftmaxOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/SqueezeOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/SubtractOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public abstract interface class sk/ainet/lang/tensor/ops/TensorOps {
	public abstract fun add (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun addScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun concat (Ljava/util/List;I)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun conv2d (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;I)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun conv2d$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun convert (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun divScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun divide (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun flatten (Lsk/ainet/lang/tensor/Tensor;II)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun flatten$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;IIILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun gelu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun matmul (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun maxPool2d (Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun maxPool2d$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun mean (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun mean$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun mulScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun multiply (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun rdivScalar (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun relu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun reshape (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun rsubScalar (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun sigmoid (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun silu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun softmax (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun softmax$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun split (Lsk/ainet/lang/tensor/Tensor;II)Ljava/util/List;
	public abstract fun sqrt (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun squeeze (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun squeeze$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun subScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun subtract (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun sum (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun sum$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun transpose (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun tril (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun tril$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun unsqueeze (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun upsample2d (Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;Z)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public abstract fun variance (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun variance$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/ops/TensorOps$DefaultImpls {
	public static synthetic fun conv2d$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun flatten$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;IIILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun maxPool2d$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun mean$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun softmax$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun squeeze$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun sum$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun tril$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;IILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun upsample2d$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;ZILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
	public static synthetic fun variance$default (Lsk/ainet/lang/tensor/ops/TensorOps;Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;ILjava/lang/Object;)Lsk/ainet/lang/tensor/Tensor;
}

public final class sk/ainet/lang/tensor/ops/TensorSpec {
	public fun <init> (Ljava/lang/String;Ljava/util/List;Ljava/lang/String;ZLjava/util/Map;)V
	public synthetic fun <init> (Ljava/lang/String;Ljava/util/List;Ljava/lang/String;ZLjava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1 ()Ljava/lang/String;
	public final fun component2 ()Ljava/util/List;
	public final fun component3 ()Ljava/lang/String;
	public final fun component4 ()Z
	public final fun component5 ()Ljava/util/Map;
	public final fun copy (Ljava/lang/String;Ljava/util/List;Ljava/lang/String;ZLjava/util/Map;)Lsk/ainet/lang/tensor/ops/TensorSpec;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/ops/TensorSpec;Ljava/lang/String;Ljava/util/List;Ljava/lang/String;ZLjava/util/Map;ILjava/lang/Object;)Lsk/ainet/lang/tensor/ops/TensorSpec;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getDtype ()Ljava/lang/String;
	public final fun getMetadata ()Ljava/util/Map;
	public final fun getName ()Ljava/lang/String;
	public final fun getRequiresGrad ()Z
	public final fun getShape ()Ljava/util/List;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/ops/TransposeOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/UnsqueezeOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/Upsample2dOperation : sk/ainet/lang/tensor/ops/BaseOperation {
	public fun <init> ()V
	public fun <init> (Ljava/util/Map;)V
	public synthetic fun <init> (Ljava/util/Map;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public fun clone (Ljava/util/Map;)Lsk/ainet/lang/tensor/ops/Operation;
	public fun execute (Ljava/util/List;)Ljava/util/List;
	public fun inferOutputs (Ljava/util/List;)Ljava/util/List;
	public fun validateInputs (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult;
}

public final class sk/ainet/lang/tensor/ops/UpsampleMode : java/lang/Enum {
	public static final field Bilinear Lsk/ainet/lang/tensor/ops/UpsampleMode;
	public static final field Nearest Lsk/ainet/lang/tensor/ops/UpsampleMode;
	public static fun getEntries ()Lkotlin/enums/EnumEntries;
	public static fun valueOf (Ljava/lang/String;)Lsk/ainet/lang/tensor/ops/UpsampleMode;
	public static fun values ()[Lsk/ainet/lang/tensor/ops/UpsampleMode;
}

public abstract class sk/ainet/lang/tensor/ops/ValidationResult {
}

public final class sk/ainet/lang/tensor/ops/ValidationResult$Invalid : sk/ainet/lang/tensor/ops/ValidationResult {
	public fun <init> (Ljava/util/List;)V
	public final fun component1 ()Ljava/util/List;
	public final fun copy (Ljava/util/List;)Lsk/ainet/lang/tensor/ops/ValidationResult$Invalid;
	public static synthetic fun copy$default (Lsk/ainet/lang/tensor/ops/ValidationResult$Invalid;Ljava/util/List;ILjava/lang/Object;)Lsk/ainet/lang/tensor/ops/ValidationResult$Invalid;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getErrors ()Ljava/util/List;
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/tensor/ops/ValidationResult$Valid : sk/ainet/lang/tensor/ops/ValidationResult {
	public static final field INSTANCE Lsk/ainet/lang/tensor/ops/ValidationResult$Valid;
}

public final class sk/ainet/lang/tensor/ops/VoidTensorOps : sk/ainet/lang/tensor/ops/TensorOps {
	public fun <init> ()V
	public fun add (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun addScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun concat (Ljava/util/List;I)Lsk/ainet/lang/tensor/Tensor;
	public fun conv2d (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;I)Lsk/ainet/lang/tensor/Tensor;
	public fun convert (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/tensor/Tensor;
	public fun divScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun divide (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun flatten (Lsk/ainet/lang/tensor/Tensor;II)Lsk/ainet/lang/tensor/Tensor;
	public fun gelu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun matmul (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun maxPool2d (Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lkotlin/Pair;Lkotlin/Pair;)Lsk/ainet/lang/tensor/Tensor;
	public fun mean (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public fun mulScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun multiply (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun rdivScalar (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun relu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun reshape (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Shape;)Lsk/ainet/lang/tensor/Tensor;
	public fun rsubScalar (Ljava/lang/Number;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun sigmoid (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun silu (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun softmax (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public fun split (Lsk/ainet/lang/tensor/Tensor;II)Ljava/util/List;
	public fun sqrt (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun squeeze (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public fun subScalar (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Number;)Lsk/ainet/lang/tensor/Tensor;
	public fun subtract (Lsk/ainet/lang/tensor/Tensor;Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun sum (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
	public fun transpose (Lsk/ainet/lang/tensor/Tensor;)Lsk/ainet/lang/tensor/Tensor;
	public fun tril (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public fun unsqueeze (Lsk/ainet/lang/tensor/Tensor;I)Lsk/ainet/lang/tensor/Tensor;
	public fun upsample2d (Lsk/ainet/lang/tensor/Tensor;Lkotlin/Pair;Lsk/ainet/lang/tensor/ops/UpsampleMode;Z)Lsk/ainet/lang/tensor/Tensor;
	public fun variance (Lsk/ainet/lang/tensor/Tensor;Ljava/lang/Integer;)Lsk/ainet/lang/tensor/Tensor;
}

public abstract interface class sk/ainet/lang/types/DType {
	public static final field Companion Lsk/ainet/lang/types/DType$Companion;
	public abstract fun getName ()Ljava/lang/String;
	public abstract fun getSizeInBits ()I
	public abstract fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public abstract fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/DType$Companion {
	public final fun findByName (Ljava/lang/String;)Lsk/ainet/lang/types/DType;
	public final fun getAllTypes ()Ljava/util/Map;
}

public final class sk/ainet/lang/types/DTypeExtensionsKt {
	public static final fun commonPrecisionWith (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
	public static final fun isConvertibleTo (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)Z
	public static final fun kotlinClass (Lsk/ainet/lang/types/DType;)Lkotlin/reflect/KClass;
}

public final class sk/ainet/lang/types/FP16 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/FP16;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/FP32 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/FP32;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Int32 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Int32;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Int4 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Int4;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/Int8 : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Int8;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/PrecisionValidationKt {
	public static final fun isValidPrecisionChain (Ljava/util/List;)Z
	public static final fun validateCompatibility (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)V
	public static final fun validateConversion (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)V
	public static final fun validatePrecisionChain (Ljava/util/List;)V
	public static final fun validatePromotion (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)V
}

public final class sk/ainet/lang/types/Ternary : sk/ainet/lang/types/DType {
	public static final field INSTANCE Lsk/ainet/lang/types/Ternary;
	public fun getName ()Ljava/lang/String;
	public fun getSizeInBits ()I
	public fun isCompatible (Lsk/ainet/lang/types/DType;)Z
	public fun promoteTo (Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
}

public final class sk/ainet/lang/types/TypeUtils {
	public static final field INSTANCE Lsk/ainet/lang/types/TypeUtils;
	public final fun areAllCompatible (Ljava/util/Collection;)Z
	public final fun areAllCompatible ([Lsk/ainet/lang/types/DType;)Z
	public final fun debugAllTypes ()V
	public final fun describe (Lsk/ainet/lang/types/DType;)Ljava/lang/String;
	public final fun findCommonType (Ljava/util/Collection;)Lsk/ainet/lang/types/DType;
	public final fun findCommonType ([Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/DType;
	public final fun getTypeByName (Ljava/lang/String;)Lsk/ainet/lang/types/DType;
	public final fun isValidTypeName (Ljava/lang/String;)Z
	public final fun promote (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)Lsk/ainet/lang/types/TypeUtils$TypePromotionBuilder;
}

public final class sk/ainet/lang/types/TypeUtils$TypePromotionBuilder {
	public fun <init> (Lsk/ainet/lang/types/DType;Lsk/ainet/lang/types/DType;)V
	public final fun getResultType ()Lsk/ainet/lang/types/DType;
	public final fun getResultTypeOrNull ()Lsk/ainet/lang/types/DType;
	public final fun isCompatible ()Z
}

public final class sk/ainet/lang/utils/table/Cell {
	public fun <init> (Ljava/lang/String;)V
	public final fun getContent ()Ljava/lang/String;
}

public final class sk/ainet/lang/utils/table/CellStyle {
	public fun <init> ()V
	public final fun getBorder ()Z
	public final fun setBorder (Z)V
}

public final class sk/ainet/lang/utils/table/Header {
	public fun <init> ()V
	public final fun getRows ()Ljava/util/List;
	public final fun row (Lkotlin/jvm/functions/Function1;)V
}

public final class sk/ainet/lang/utils/table/Row {
	public fun <init> ()V
	public final fun cell (Ljava/lang/Object;)V
	public final fun getCells ()Ljava/util/List;
}

public final class sk/ainet/lang/utils/table/Table {
	public fun <init> ()V
	public final fun cellStyle (Lkotlin/jvm/functions/Function1;)V
	public final fun getCellStyle ()Lsk/ainet/lang/utils/table/CellStyle;
	public final fun getHeader ()Lsk/ainet/lang/utils/table/Header;
	public final fun getRows ()Ljava/util/List;
	public final fun header (Lkotlin/jvm/functions/Function1;)V
	public final fun row (Lkotlin/jvm/functions/Function1;)V
	public final fun setHeader (Lsk/ainet/lang/utils/table/Header;)V
	public fun toString ()Ljava/lang/String;
}

public final class sk/ainet/lang/utils/table/TableBuilderKt {
	public static final fun table (Lkotlin/jvm/functions/Function1;)Lsk/ainet/lang/utils/table/Table;
}

